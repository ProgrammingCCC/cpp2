#+title: Week 8
#+author: kstatz@colum.edu

* The Problem With pointers
Raw pointers are the basic way of returning something or passing something by reference. Pointers are used when the life cycle of a variable in memory is longer than the function that declared it. The problem is ownership. Who owns the pointer once it has been returned from a method?

* Returning By Value

#+BEGIN_SRC cpp
T foo() {
  T t = T();
  return t;
}
#+END_SRC

This code block allocates t on the stack and, worst case, will copy t to the caller. Copying happens because we cannot share stack memory outside of the function scope.

* Named Return Value optimization

NRVO is a compiler optimization for return values. When the compiler sees the following block:

#+BEGIN_SRC cpp
struct A {
  A();
  A(const A &) { std::cout << "Copy" << std::endl; }
};

A foo() { return A(); }


std::cout << "Hello World" << std::endl;
A a = foo();
#+END_SRC

it will either print out one of the following based on compiler settings, version etc

#+BEGIN_QUOTE
"Hello World"
"Copy"
"Copy"
#+END_QUOTE

This is worst case where the constructor call to A() gets copied to a hidden temporary value and then copied t the variable 'a' on return

#+BEGIN_QUOTE
"Hello World"
"Copy"
#+END_QUOTE

This is generally what happens without optimization. the value generated by the constructor call gets copied to `a`

#+BEGIN_QUOTE
"Hello World"
#+END_QUOTE

This is with NRVO, where the function return is replaced by the value which is A();

* Optimizing value returns with move semantics

starting in c++11 move operations. Move "steals" the value from a variable and moves it to another skipping the copy where both values exist for a time.

#+BEGIN_SRC cpp
T foo() {
  T t = T();
  std::move(t);
  return t;
}
#+END_SRC
